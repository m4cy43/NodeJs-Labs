Лабораторна робота №2 
з дисципліни «Основи розроблення програмного забезпечення на платформі Node.js» 
Тема: «Робота з файлами та мережею»

Виконали: студенти групи ІТ-04 Коновальчук Андрій Володимирович, Полтава Віолетта Віталіївна, Яцентій Богдан Богданович

Хід роботи:
1. Ознайомитися  із стандартними бібліотеками Node.js для роботи з файлами та мережею - fs, net, http. 
2. В данній роботі необхідно реалізувати найпростіший web-scrapper. Необхідно обрати веб-сайт з новинами будь-якої тематики. Додаток має мати наступний функціонал:
- Раз в хвилину відправляти запит на головну сторінку та отримувати відповідь. 
- Обробити отриману HTML відповідь, а саме отримати список новин.
- Отримані новини зберегети в директорії. Кожна новина в окремому файлі. 
- Реалізувати найпростший веб-сервер (бібліотеку net), який віддає список файлів у директорії 
- При кліку по елементу списка - віддавати текст новини.
3. Приклад парсинг html сторінки наданий в посиланнях.

Контрольні питання:
1. В чому різниця між setTimeout та setInterval?

setTimeout та setInterval - це два методи, які дозволяють виконувати код через певний час після його виклику. 
setTimeout дозволяє запускати функцію один раз через певний інтервал часу, тоді як setInterval дозволяє запускати функцію багаторазово через певний інтервал часу.

Єдина *відмінність* між ними полягає в тому, що setTimeout виконується лише один раз, а setInterval повторюється через певний проміжок часу.
Наприклад, якщо потрібно виконати функцію лише один раз через певний час, то це setTimeout. А якщо потрібно виконувати функцію багаторазово через певний проміжок часу, то це setInterval.

2. Що таке блокуючи код? 

Блокуючий код - це код, який зупиняє виконання програми до того моменту, поки він не буде завершений. Це означає, що програма не може продовжувати виконуватися, поки блокуючий код не буде завершений. 

У Node.js блокуючий код може виникати, коли виконується довгий запит до бази даних або коли виконується довгий цикл. Це може призвести до затримок у відповіді сервера та негативно позначитися на продуктивності сервера.

Щоб уникнути блокування коду в Node.js, можна використовувати асинхронний код. Асинхронний код дозволяє продовжувати виконання програми під час очікування результатів запиту до бази даних або іншої операції.

3. Які переваги асинхронного читання з диску перед синхроним? 
- Обробка помилок: асинхронне читання з диску може обробляти помилки. Зазвичай, при синхронному читанні з диску, будь-яка помилка зупиняє виконання програми. Це забезпечує більш стабільну роботу програми.
- Ефективність: асинхронне читання з диска дозволяє продовжувати виконувати інші завдання в очікуванні результатів запиту на диск. Це може зменшити затримки відповіді сервера та покращити продуктивність сервера. Відповідно, це дозволяє виконуати більше операцій в секунду і знижує час очікування.
- Простота коду: асинхронний код може бути легшим для розуміння та написання, оскільки він не вимагає використання операцій блокування.
- Масштабованість: асинхронний код дозволяє обробляти багато запитів одночасно. Це особливо важливо для веб-серверів, які отримують багато таких запитів, адже асинхронні операції можуть допомогти уникнути того ж блокування.
- Робота із файлами великого розміру: асинхронне читання з диску дозволяє читати файли великого розміру, не знижуючи продуктивність застосунку.

4. Опишіть різницю між Callbacks API, Promise API та async / await. 

Callbacks, Promises, та async/await — це все способи обробки асинхронного коду. Вони використовуються для того, щоб виконувати асинхронні операції, які можуть зайняти деякий час, і не блокувати виконання програми.

- Callbacks API: Callback — це функція, яка викликається після завершення завдання, що допомагає уникнути будь-яких блокувань і дозволяє тим часом виконуватись іншому коду. Callback — це асинхронний аналог функції, яка викликається після виконання завдання. 
Завдяки ідеї Callback Node.js може обробляти величезну кількість запитів, не чекаючи, поки функція видасть результат, що робить його дуже масштабованим. Callbacks дозволяють виконувати асинхронний код, але вони можуть призвести до вкладеності функцій, що забезпечує важкість в розумінні коду.
Розглянемо такий сценарій: коли функція в Node.js починає читати файл, вона миттєво повертає керування середовищу виконання, щоб можна було виконати наступну інструкцію. Щоб уникнути блокування або очікування введення/виведення файлу, функція Callback буде викликана після завершення введення/виведення файлу.

- Promise API: Promises — це об’єкти, які є вдосконаленням Callback функцій, які керують усіма асинхронними даними. Promise представляє дію, яка буде виконана або відхилена. Якщо Promise виконана, вона вирішена; інакше воно відхиляється. Promises, на відміну від типових Callback функцій, можуть бути зв’язані.
Як працюють Promises?
Promises мають три стани: pending, resolved та rejected. Рending state — це початковий стан, який виникає під час виклику Promise. Поки Promise очікує на розгляд, функція, що викликає, продовжує працювати, доки Promise не буде виконана, повертаючи будь-які дані, які були запитані до функції, що викликає. Коли Promise виконано, вона закінчується або в стані resolved, або у стані rejected. 
Resolved state вказує на те, що Promise була успішною та що потрібні дані передано в метод .then().
Rejected state вказує на те, що обіцянка відхилена, і помилка передається в метод .catch().

- async/await: це новіший спосіб обробки асинхронного коду в JavaScript. Він створений на основі Promises і забезпечує чистіший синтаксис для обробки асинхронного коду. Ключове слово async використовується для визначення асинхронної функції, а ключове слово await використовується для очікування вирішення Promise.
Слово "async" перед функцією означає просту річ: функція завжди повертає promise. Інші значення автоматично загортаються в resolved promise. 
Слово "await" працює лише в асинхронних функціях. Тобто призупиняє виконання функції, доки promise не завершиться, а потім відновлює її з результатом promise.

5. Як обробляються помилки при використанні Promise API? 

У Node.js обробка помилок за допомогою Promise API виконується за допомогою методу .catch(). Цей метод обробляє помилки в промісах усіх видів: будь то виклик reject() або помилка, викинута в обробнику. 
.then() також виловлює помилки таким же чином, якщо надати другий аргумент (який є обробником помилок). 
.catch() треба розміщувати саме там, де ми хочемо обробляти помилки та знати, як їх обробляти. Обробник повинен проаналізувати помилки і вирішити, що з ними робити. 


6. Як cтворити директорію через модуль fs? За що відповідає параметр mode? 

